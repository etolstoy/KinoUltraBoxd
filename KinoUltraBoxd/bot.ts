import { Telegraf, Context, Markup } from 'telegraf';
import { Message } from 'telegraf/typings/core/types/typegram';
import * as dotenv from 'dotenv';
import { downloadHtmlFiles } from './services/telegramFileService';
import { process as processFilms } from './services/filmProcessingService';
import { registerSelectionHandler } from './manualSelectionHandler';
import { BotSessionState } from './models/SessionModels';
import { sessionManager } from './services/sessionManager';
import { buildStatsReport } from './services/statsReportService';
import { generateLetterboxdCsv } from './services/letterboxdExportService';
import { FilmData } from './models/FilmData';

dotenv.config();

export const bot = new Telegraf(process.env.BOT_TOKEN as string);

// Start command with inline "Start export" button
bot.start(async (ctx: Context) => {
  // Reset any previously uploaded files when /start is invoked
  const userId = ctx.from?.id;
  if (userId) {
    const session = await loadState(userId);
    session.fileQueue = { file_ids: [], file_names: [] };
    await saveState(userId, session);
  }
  const keyboard = Markup.inlineKeyboard([
    [Markup.button.callback('‚úÖ –ù–∞—á–∞—Ç—å —ç–∫—Å–ø–æ—Ä—Ç', 'export_start')],
  ]);

  await ctx.reply(
    'üé¨ –ü—Ä–∏–≤–µ—Ç! –Ø –ø–æ–º–æ–≥—É —Ç–µ–±–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ–∏–ª—å–º—ã —Å –ö–∏–Ω–æ–ø–æ–∏—Å–∫–∞ –Ω–∞ Letterboxd. –î–ª—è –Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ HTML-—Ñ–∞–π–ª—ã —Å —Ç–≤–æ–∏–º–∏ –æ—Ü–µ–Ω–∫–∞–º–∏. –ß—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å, –æ—Ç–∫—É–¥–∞ –∏—Ö –≤–∑—è—Ç—å, –≤—ã–∑–æ–≤–∏ –∫–æ–º–∞–Ω–¥—É /help\n\n–ö–æ–≥–¥–∞ —Ç—ã –∑–∞–≥—Ä—É–∑–∏—à—å —Ñ–∞–π–ª—ã, –Ω–∞–∂–º–∏ ‚úÖ –∫–Ω–æ–ø–∫—É –ø–æ–¥ —ç—Ç–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º. –ê –µ—Å–ª–∏ –≤–¥—Ä—É–≥ —á—Ç–æ-—Ç–æ –ø–æ–π–¥–µ—Ç –Ω–µ —Ç–∞–∫, –Ω–∞–ø–∏—à–∏ @etolstoy!',
    keyboard,
  );
});

// ---------------- Session & persistence layer ----------------
const loadState = (userId: number) => sessionManager.get(userId);
const saveState = (userId: number, state: BotSessionState) => sessionManager.set(userId, state);

// ---------------- Help command ----------------
const helpMessage = `1Ô∏è‚É£ –û—Ç–∫—Ä–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å–æ —Å–≤–æ–∏–º–∏ –æ—Ü–µ–Ω–∫–∞–º–∏ –Ω–∞ –ö–∏–Ω–æ–ø–æ–∏—Å–∫–µ:\n‚Ä¢ –ü–µ—Ä–µ–π–¥–∏ –Ω–∞ [—Å–∞–π—Ç –ö–∏–Ω–æ–ø–æ–∏—Å–∫–∞](https://www.kinopoisk.ru/)\n‚Ä¢ –í–æ–π–¥–∏ –≤ —Å–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç\n‚Ä¢ –ù–∞–∂–º–∏ –Ω–∞ —Å–≤–æ–π –∞–≤–∞—Ç–∞—Ä –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É\n‚Ä¢ –í—ã–±–µ—Ä–∏—Ç–µ "–û—Ü–µ–Ω–∫–∏"\n\n2Ô∏è‚É£ –ù–∞—Å—Ç—Ä–æ–π –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ñ–∏–ª—å–º–æ–≤ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ:\n‚Ä¢ –í –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É —Å–ø–∏—Å–∫–∞ —Ñ–∏–ª—å–º–æ–≤ –Ω–∞–π–¥–∏ –≤—ã–ø–∞–¥–∞—é—â–µ–µ –º–µ–Ω—é\n‚Ä¢ –í—ã–±–µ—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ 200 —Ñ–∏–ª—å–º–æ–≤ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ\n\n3Ô∏è‚É£ –°–æ—Ö—Ä–∞–Ω–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—É –∫–∞–∫ HTML-—Ñ–∞–π–ª:\n‚Ä¢ –í Chrome/Edge: –ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏ ‚Üí –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫... ‚Üí –í—ã–±–µ—Ä–∏ "–í–µ–±-—Å—Ç—Ä–∞–Ω–∏—Ü–∞, –ø–æ–ª–Ω–æ—Å—Ç—å—é"\n‚Ä¢ –í Firefox: –ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏ ‚Üí –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É –∫–∞–∫... ‚Üí –í—ã–±–µ—Ä–∏ "–í–µ–±-—Å—Ç—Ä–∞–Ω–∏—Ü–∞, –ø–æ–ª–Ω–æ—Å—Ç—å—é"\n‚Ä¢ –í Safari: –§–∞–π–ª ‚Üí –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫... ‚Üí –í—ã–±–µ—Ä–∏ —Ñ–æ—Ä–º–∞—Ç "–í–µ–±-–∞—Ä—Ö–∏–≤"\n‚Ä¢ –°–æ—Ö—Ä–∞–Ω–∏ —Ñ–∞–π–ª –≤ —É–¥–æ–±–Ω–æ–µ –º–µ—Å—Ç–æ –Ω–∞ –≤–∞—à–µ–º –∫–æ–º–ø—å—é—Ç–µ—Ä–µ\n\n4Ô∏è‚É£ –ï—Å–ª–∏ –ø–æ–ª—É—á–∏–ª–æ—Å—å –±–æ–ª—å—à–µ 200 –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö —Ñ–∏–ª—å–º–æ–≤:\n‚Ä¢ –ü–µ—Ä–µ–π–¥–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É —Å –ø–æ–º–æ—â—å—é –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ –≤–Ω–∏–∑—É —Å–ø–∏—Å–∫–∞\n‚Ä¢ –ü–æ–≤—Ç–æ—Ä–∏ –ø—Ä–æ—Ü–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–ª—è –∫–∞–∂–¥–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã\n‚Ä¢ –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –Ω–∞–∑—ã–≤–∞—Ç—å —Ñ–∞–π–ª—ã –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, kinopoisk1.html, kinopoisk2.html)\n\n5Ô∏è‚É£ –ü–æ–≤—Ç–æ—Ä–∏ —Ç–æ –∂–µ —Å–∞–º–æ–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã—Ö, –Ω–æ –Ω–µ –æ—Ü–µ–Ω–µ–Ω–Ω—ã—Ö —Ñ–∏–ª—å–º–æ–≤:\n‚Ä¢ –í –≤—ã–ø–∞–¥–∞—é—â–µ–º –º–µ–Ω—é "–ø–æ–∫–∞–∑–∞—Ç—å" –ø–æ–º–µ–Ω—è–π "–æ—Ü–µ–Ω–∫–∏" –Ω–∞ "–ø—Ä–æ—Å–º–æ—Ç—Ä—ã"\n‚Ä¢ –°–æ—Ö—Ä–∞–Ω–∏ –∫–∞–∂–¥—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–æ —Ç–æ–º—É –∂–µ –∞–ª–≥–æ—Ä–∏—Ç–º—É\n\n6Ô∏è‚É£ –ó–∞–≥—Ä—É–∑–∏ –≤—Å–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ HTML-—Ñ–∞–π–ª—ã –≤ —ç—Ç–æ—Ç —á–∞—Ç:\n‚Ä¢ –ù–∞–∂–º–∏ –Ω–∞ —Å–∫—Ä–µ–ø–∫—É (üìé) –≤ –ø–æ–ª–µ –≤–≤–æ–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏—è\n‚Ä¢ –í—ã–±–µ—Ä–∏ "–§–∞–π–ª"\n‚Ä¢ –ù–∞–π–¥–∏ –∏ –≤—ã–±–µ—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ HTML-—Ñ–∞–π–ª—ã\n‚Ä¢ –û—Ç–ø—Ä–∞–≤—å –∏—Ö –≤ —á–∞—Ç\n`;

bot.command('help', async (ctx: Context) => {
  await ctx.reply(helpMessage, { parse_mode: 'Markdown' });
});

// ---------------- Helper ----------------
// Remove previously saved temporary status message (if any)
async function clearTempStatus(ctx: Context, session: BotSessionState): Promise<void> {
  if (session.tempStatusMessageId) {
    try {
      await ctx.telegram.deleteMessage(ctx.chat!.id, session.tempStatusMessageId);
    } catch (_) {
      // Ignore deletion errors (message might be too old or already deleted)
    }
    delete (session as any).tempStatusMessageId;
    await saveState(ctx.from!.id, session);
  }
}

async function sendStatsReport(ctx: Context, films: FilmData[]): Promise<void> {
  const session = await loadState(ctx.from!.id);
  await clearTempStatus(ctx, session);

  const report = buildStatsReport(films);
  await ctx.reply(report.message, { parse_mode: 'Markdown' });
  if (report.notFoundFilms && report.notFoundFilms.length > 0) {
    const buffer = Buffer.from(report.notFoundFilms.join('\n'), 'utf-8');
    await ctx.replyWithDocument({ source: buffer, filename: 'not_found_films.txt' });
  }

  // Export CSV for Letterboxd
  if (report.stats.exportableCount > 0) {
    const csvBuffer = generateLetterboxdCsv(films);
    await ctx.replyWithDocument({ source: csvBuffer, filename: 'letterboxd.csv' });
  }
}

// Register manual selection handler
registerSelectionHandler(bot, sendStatsReport);

bot.on('document', async (ctx: Context) => {
  const doc = (ctx.message as Message.DocumentMessage).document;
  const userId = ctx.from?.id;
  if (!userId) return;

  // Queue the file for this user (persisted)
  const session = await loadState(userId);
  session.fileQueue.file_ids.push(doc.file_id);
  session.fileQueue.file_names.push(doc.file_name || 'unnamed.html');
  await saveState(userId, session);
});

// Helper processing function reused in multiple places
async function processQueuedFiles(ctx: Context, session: BotSessionState): Promise<void> {
  const queue = session.fileQueue;
  if (!queue || queue.file_ids.length === 0) {
    await clearTempStatus(ctx, session);
    await ctx.reply('‚ùå –ö–∞–∂–µ—Ç—Å—è, —Ç—ã –µ—â–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–∏–ª —Ñ–∞–π–ª—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π –∏—Ö –ø—Ä–∏—Å–ª–∞—Ç—å –µ—â–µ —Ä–∞–∑.');
    return;
  }

  // Suppress noisy progress message ‚Äì keep chat concise while processing files

  let htmlContents: string[] = [];
  try {
    htmlContents = await downloadHtmlFiles(ctx.telegram, queue.file_ids);
  } catch (err) {
    console.error('[bot] file download failed', err);
    await clearTempStatus(ctx, session);
    await ctx.reply('‚ùå –ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —Ñ–∞–π–ª—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.');
    return;
  }

  // ---------- Process downloaded HTML ----------
  try {
    const films = await processFilms(htmlContents, session.kinopoiskToken);

    // Identify films that need manual disambiguation
    const needManual = films
      .map((f, idx) => ({ film: f, idx }))
      .filter(({ film }) => film.potentialMatches && film.potentialMatches.length > 0);

    if (needManual.length === 0) {
      await clearTempStatus(ctx, session);
      await sendStatsReport(ctx, films);
      await sessionManager.clearSelection(ctx.from!.id);
    } else {
      // Save state and start interactive selection
      // Inform user about auto-processed films vs those requiring manual disambiguation
      const processedCount = films.filter((f) => f.tmdbId != null || f.imdbId != null).length;
      const manualCount = films.filter((f) => f.type === 'film' && f.tmdbId == null && f.imdbId == null).length;
      const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('‚úÖ –ü–æ–≥–Ω–∞–ª–∏ —Ä–∞–∑–±–∏—Ä–∞—Ç—å—Å—è', 'manual_start')],
        [Markup.button.callback('üõë –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å –≤—Å–µ', 'skip_all')],
      ]);

      await clearTempStatus(ctx, session);
      await ctx.reply(
        `üëç –•–æ—Ä–æ—à–∏–µ –Ω–æ–≤–æ—Å—Ç–∏ ‚Äì —è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±—Ä–∞–±–æ—Ç–∞–ª ${processedCount} —Ñ–∏–ª—å–º–æ–≤, –∏ –æ–Ω–∏ —É–∂–µ –≥–æ—Ç–æ–≤—ã –∫ –∏–º–ø–æ—Ä—Ç—É –Ω–∞ Letterboxd!\n\n–ù–æ –µ—â–µ ${manualCount} –Ω–∞–¥–æ –æ–±—Å—É–¥–∏—Ç—å —Å —Ç–æ–±–æ–π. –°–º–æ–∂–µ—à—å –ø–æ–º–æ—á—å –≤—ã–±—Ä–∞—Ç—å –∏–∑ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π?`,
        keyboard,
      );

      session.selection = {
        films,
        selectionQueue: needManual.map(({ idx }) => idx),
        currentIdx: 0,
      };
      await saveState(ctx.from!.id, session);
    }

    // Success ‚Üí clear queue
    session.fileQueue = { file_ids: [], file_names: [] };
    await saveState(ctx.from!.id, session);
  } catch (err: any) {
    if (err instanceof Error && err.message === 'KIN_TOKEN_MISSING') {
      // Ask user for token and keep queue intact
      await clearTempStatus(ctx, session);
      const tokenRequestMsg = await ctx.reply(
        'üôãüèª –ß–∞—Å—Ç—å —Ñ–∏–ª—å–º–æ–≤ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞, –Ω–æ –Ω–∞–π—Ç–∏ –ø–æ–∫–∞ –ø–æ–ª—É—á–∏–ª–æ—Å—å –Ω–µ –≤—Å–µ. –ù–∞–º –ø—Ä–∏–¥–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π API –ö–∏–Ω–æ–ø–æ–∏—Å–∫–∞, –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫–æ—Ç–æ—Ä—ã–º —Ç–µ–±–µ –Ω–∞–¥–æ –ø–æ–ª—É—á–∏—Ç—å –ª–∏—á–Ω—ã–π —Ç–æ–∫–µ–Ω. –≠—Ç–æ –±–µ—Å–ø–ª–∞—Ç–Ω–æ –∏ –æ—á–µ–Ω—å –ø—Ä–æ—Å—Ç–æ ‚Äì –Ω–∞–ø–∏—à–∏ @kinopoiskdev_bot, –∏ –º–µ–Ω—å—à–µ —á–µ–º –∑–∞ –º–∏–Ω—É—Ç—É —Ç–æ–∫–µ–Ω –±—É–¥–µ—Ç —É —Ç–µ–±—è. –ü—Ä–∏—à–ª–∏ –µ–≥–æ –≤ –æ—Ç–≤–µ—Ç –Ω–∞ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∏ —è –ø—Ä–æ–¥–æ–ª–∂—É!',
      );
      // Treat the token request as a temporary status message to keep the chat clean later
      session.tempStatusMessageId = (tokenRequestMsg as any).message_id;
      session.awaitingKinopoiskToken = true;
      await saveState(ctx.from!.id, session);
      return;
    }

    console.error('[bot] film processing failed', err);
    await clearTempStatus(ctx, session);
    await ctx.reply('‚ùå –ö–∞–∫–∏–µ-—Ç–æ –ø—Ä–æ–±–ª–µ–º—ã —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π —Ñ–∞–π–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –Ω–∞–ø–∏—à–∏ @etolstoy!');
  }
}

bot.hears(/^go$/i, async (ctx: Context) => {
  const userId = ctx.from?.id;
  if (!userId) return;
  const session = await loadState(userId);
  await processQueuedFiles(ctx, session);
});

// Handle "Start export" button press
bot.action('export_start', async (ctx) => {
  const userId = ctx.from?.id;
  if (!userId) return;

  const session = await loadState(userId);

  // If there are no queued files, keep the button and inform the user
  if (!session.fileQueue || session.fileQueue.file_ids.length === 0) {
    await ctx.answerCbQuery('‚ùå –°–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤—å HTML-—Ñ–∞–π–ª—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏', { show_alert: true });
    return; // do NOT remove the button
  }

  await ctx.answerCbQuery(); // acknowledge button press

  // Remove the button but keep the original message
  try {
    await ctx.editMessageReplyMarkup(undefined);
  } catch (_) {
    // Ignore errors (e.g., if message too old to edit)
  }

  // Show temporary processing status
  const statusMsg = await ctx.reply('‚è∞ –ù–∞—á–∞–ª –æ–±—Ä–∞–±–æ—Ç–∫—É —Ç–≤–æ–∏—Ö —Ñ–∏–ª—å–º–æ–≤. –°–∫–æ—Ä–æ –≤—Å–µ –±—É–¥–µ—Ç!');
  session.tempStatusMessageId = (statusMsg as any).message_id;
  await saveState(userId, session);

  await processQueuedFiles(ctx, session);
});

// Capture Kinopoisk token when awaiting
bot.on('text', async (ctx: Context) => {
  const userId = ctx.from?.id;
  if (!userId) return;

  const session = await loadState(userId);
  if (!session.awaitingKinopoiskToken) return; // Not expecting token

  const token = (ctx.message as any).text?.trim();
  if (!token) return;

  // Remove the user's message containing the sensitive token to keep the chat history clean
  try {
    // deleteMessage without params deletes the message that triggered the current ctx
    await ctx.deleteMessage();
  } catch (_) {
    // Ignore deletion errors (e.g., insufficient rights or message too old)
  }

  session.kinopoiskToken = token;
  session.awaitingKinopoiskToken = false;
  await saveState(userId, session);

  await clearTempStatus(ctx, session);

  // Send a new temporary status message while continuing processing
  const processingMsg = await ctx.reply('üîê –û—Ç–ª–∏—á–Ω–æ, —Å–ø–∞—Å–∏–±–æ –∑–∞ —Ç–æ–∫–µ–Ω! –ü—Ä–æ–¥–æ–ª–∂–∞—é –æ–±—Ä–∞–±–æ—Ç–∫—É —Ñ–∞–π–ª–æ–≤...');
  session.tempStatusMessageId = (processingMsg as any).message_id;
  await saveState(userId, session);

  // Retry processing queue automatically
  await processQueuedFiles(ctx, session);
});

if (!process.env.VERCEL) {
  bot.launch();

  // Enable graceful stop when running locally (long polling)
  process.once('SIGINT', () => bot.stop('SIGINT'));
  process.once('SIGTERM', () => bot.stop('SIGTERM'));
}

export default bot; 